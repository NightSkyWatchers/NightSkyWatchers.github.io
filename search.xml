<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记奇特的调试bug]]></title>
    <url>%2F2018%2F09%2F04%2F%E8%AE%B0%E5%A5%87%E7%89%B9%E7%9A%84%E8%B0%83%E8%AF%95bug%2F</url>
    <content type="text"><![CDATA[传进来的model有值，并且可以打印model模型所有值；但是打印model模型中的title、image、sort属性的时候，不是为nil，就是报错如下：Execution was interrupted, reason: Attempted to dereference an invalid ObjC Object or send it an unrecognized selector. The process has been returned to the state before expression evaluation 原因排查：打印的model为一个字典123456789101112131415&#123;id = ad3886be78de49c8a6f66dfe9ba715fa,enable = 0,album = 1,delFlag = 1,ifBuy = 0,createDate = 1505893668000,vtime = ,type = 0,title = 微课堂,price = 1,image = 65617e87de1c4084ba1b78a673363b99,updateDate = 1508724726000,sort = 1&#125; 正确的打印出来如下：12345678910111213(lldb) po model.yy_modelDescription&lt; videosModel: 0x600002a75700&gt; &#123;enable = &quot;0&quot;;ifBuy = 0;image = &quot;b31e4d4ac6fd472babe9bae7c768bc0d&quot;;price = 2;title = &quot;政策解读1&quot;;type = &quot;1&quot;;videoId = &quot;4bb5310dcb9d4e7cb20aa00796da921f&quot;&#125;(lldb) po model&lt; videosModel: 0x600002a75700&gt; 排查得出结果：网络请求回来的json类型数据没有转换为模型类型！！！ 查看模型中的声明和实现如下12345678910111213141516171819202122232425262728293031.h@interface videosModel : NSObject@property (nonatomic, copy) NSString *videoId;@property (nonatomic, copy) NSString *title;@property (nonatomic, copy) NSString *type;@property (nonatomic, copy) NSString *enable;@property (nonatomic, copy) NSString *image;@property (nonatomic, assign) NSInteger ifBuy;@property (nonatomic, strong) NSNumber *price;@end@interface videosListModel : NSObject@property (nonatomic, strong) NSArray &lt; videosModel *&gt; *videos;@end.m@implementation videosModel+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelCustomPropertyMapper &#123;return @&#123;@&quot;videoId&quot;:@&quot;id&quot;&#125;;&#125;@end@implementation videosListModel@end 在.m文件中缺少了YYModel的类方法（自定义容器类属性映射模型类的方法）123+ (NSDictionary *)modelContainerPropertyGenericClass &#123;return @&#123;@&quot;videos&quot; : [videosModel class]&#125;;&#125;]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包裹BOOL值NSNumber对象和等价的三目运算区别何在]]></title>
    <url>%2F2018%2F09%2F03%2F%E5%8C%85%E8%A3%B9BOOL%E5%80%BCNSNumber%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%AD%89%E4%BB%B7%E7%9A%84%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E5%8C%BA%E5%88%AB%E4%BD%95%E5%9C%A8%2F</url>
    <content type="text"><![CDATA[后台人员提供了一个网络请求接口，接口文档如下：使用字典将参数传递过来给后台，移动端提供的参数isAttention是BOOL类型，要转换成后台所需要的int类型；因为字典之中键值只能是对象类型，以往都是将int类型包装成NSNumber类型放在字典里进行传递，请求准确无误。123方式一 ： &#123;@&quot;isAttention&quot;:@(isAttention)&#125;方式二 ： [NSNumber numberWithBool:attention]方式三 ： attention ? @1 : @0 不巧的是，今天使用上述两种方式都报错–400. Error Domain=NSCocoaErrorDomain Code=3840 &quot;JSON text did not start with array or object and option to allow fragments not set.&quot; UserInfo={NSDebugDescription=JSON text did not start with array or object and option to allow fragments not set., NSUnderlyingError=0x604000c51100 {Error Domain=com.alamofire.error.serialization.response Code=-1011 &quot;Request failed: bad request (400)&quot; UserInfo={NSLocalizedDescription=Request failed: bad request (400), NSErrorFailingURLKey=http://test.******.com/jsb_webserver/attention/user, com.alamofire.serialization.response.error.data = &lt;........&gt;, com.alamofire.serialization.response.error.response=&lt;NSHTTPURLResponse: 0x60400082f140&gt; { URL: http://test.******.com/jsb_webserver/attention/user } { Status Code: 400, Headers { Connection = [ close ], Content-Language = [ en ], Content-Type = [ text/html;charset=utf-8 ], Content-Length = [ 1003 ], Date = [ Mon, 03 Sep 2018 06:34:01 GMT ] } }}}}最终使用第三种方式包装BOOL类型参数，请求成功的！！！但是本人还是有些不解，前两种写法和第三种有什么本质上的区别，求大神不吝赐教！！！]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导航栏状态栏通透ios11适配]]></title>
    <url>%2F2018%2F08%2F22%2F%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%8A%B6%E6%80%81%E6%A0%8F%E9%80%9A%E9%80%8Fios11%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[想要实现状态栏通透的效果：iOS10及以下设备设置控制器12345678- (void)viewDidLoad &#123;[super viewDidLoad];// 设置导航栏的背景图透明[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];// 设置导航栏底部线不显示[self.navigationController.navigationBar setShadowImage:[UIImage new]];self.automaticallyAdjustsScrollViewInsets = NO; // 9.0设备上&#125; 在ios11的设备上，可以设置UIScrollView的contentInsetAdjustmentBehavior的属性； 例如：设置tableView的contentInsetAdjustmentBehavior的属性12345if (@available(iOS 11.0, *)) &#123;_tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;&#125; else &#123;// Fallback on earlier versions&#125; 查看这个属性的相关信息得知，将要废除，并有新的属性替换1@property(nonatomic,assign) BOOL automaticallyAdjustsScrollViewInsets API_DEPRECATED_WITH_REPLACEMENT(&quot;Use UIScrollView&apos;s contentInsetAdjustmentBehavior instead&quot;, ios(7.0,11.0),tvos(7.0,11.0)); // Defaults to YES 因为控制器的automaticallyAdjustsScrollViewInsets默认是YES，也就是控制器的视图会自动适应导航栏和状态栏的缩进；反之不自动适应，则从屏幕顶部开始。 UIScrollViewContentInsetAdjustmentBehavior同理,设置UIScrollViewContentInsetAdjustmentNever则不自动适应，从屏幕顶部开始。123456typedef NS_ENUM(NSInteger, UIScrollViewContentInsetAdjustmentBehavior) &#123;`UIScrollViewContentInsetAdjustmentAutomatic, // Similar to .scrollableAxes, but for backward compatibility will also adjust the top &amp; bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewInsets = YES inside a navigation controller, regardless of whether the scroll view is scrollableUIScrollViewContentInsetAdjustmentScrollableAxes, // Edges for scrollable axes are adjusted (i.e., contentSize.width/height &gt; frame.size.width/height or alwaysBounceHorizontal/Vertical = YES)UIScrollViewContentInsetAdjustmentNever, // contentInset is not adjustedUIScrollViewContentInsetAdjustmentAlways, // contentInset is always adjusted by the scroll view&apos;s safeAreaInsets`&#125; API_AVAILABLE(ios(11.0),tvos(11.0));]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP上架被拒日常(6)-IPv6 网络错误]]></title>
    <url>%2F2018%2F06%2F07%2FAPP%E4%B8%8A%E6%9E%B6%E8%A2%AB%E6%8B%92%E6%97%A5%E5%B8%B8(6)-IPv6%20%20%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[原文We discovered one or more bugs in your app when reviewed on iPhone running iOS 11.1 on Wi-Fi connected to an IPv6 network.Specifically, your app still displays a network error message and we are unable to log in.Please see attached screenshots for details.Next StepsTo resolve this issue, please run your app on a device to identify any issues, then revise and resubmit your app for review.If we misunderstood the intended behavior of your app, please reply to this message in Resolution Center to provide information on how these features were intended to work.For new apps, uninstall all previous versions of your app from a device, then install and follow the steps to reproduce the issue. For updates, install the new version as an update to the previous version, then follow the steps to reproduce the issue.ResourcesFor information about testing your app and preparing it for review, please see Technical Note TN2431: App Testing Guide.For a networking overview, please review About Networking. For a more specific overview of App Review’s IPv6 requirements, please review the IPv6 and App Review discussion on the Apple Developer Forum. 译文:当在连接到IPv6网络的Wi-Fi上运行ios11.1时，我们在应用程序中发现了一个或多个错误。具体来说，您的应用程序仍然显示一个网络错误信息，我们无法登录。详情请见附件截图。下一个步骤要解决这个问题，请在设备上运行您的应用程序来识别任何问题，然后修改并重新提交您的应用程序以供审查。如果我们误解了您的应用程序的意图行为，请在Resolution Center中回复此消息，以提供这些特性如何工作的信息。对于新的应用程序，从设备上卸载之前所有的应用程序，然后安装并执行复制问题的步骤。对于更新，将新版本作为以前版本的更新安装，然后按照以下步骤重新生成问题。资源有关测试您的应用程序并准备进行审查的信息，请参阅技术说明TN2431:应用程序测试指南。要了解网络概况，请回顾网络。关于应用程序审查的IPv6需求的更具体的概述，请回顾一下关于苹果开发者论坛的IPv6和应用程序审查讨论。 解决方案针对被拒内容中提到了IPv6 网络环境下,网络错误导致无法登录! 首先保证登录接口/截图中展示页面内网络接口能够正常使用,以防止在苹果审核期间宕机无法使用弹出网络错误的提示框; 其次搭建IPv6 的网络环境,并且录制使用APP的视频,上传到youtube上,并获取该视频的播放地址. 在重新打包提交的备注信息里或者问题中心的回复框里,附带上述视频地址以及相关解释说辞,提交审核即可. 附上截图:]]></content>
      <categories>
        <category>发布上架</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP上架被拒日常(5)-Payments - In-App Purchase]]></title>
    <url>%2F2018%2F06%2F07%2FAPP%E4%B8%8A%E6%9E%B6%E8%A2%AB%E6%8B%92%E6%97%A5%E5%B8%B8(5)-Payments%20-%20In-App%20Purchase%2F</url>
    <content type="text"><![CDATA[被拒(一)原文Hello,Thank you for providing the information. After further review, we found the following rejection:We noticed that your app or its metadata enables the purchase of content, services, or functionality in the app by means other than the in-app purchase API, which is not appropriate for the App Store.The next submission of this app may require a longer review time.Next Steps Review the In-App Purchase section of the App Store Review Guidelines. Ensure your app is compliant with all sections of the App Store Review Guidelines and the Terms &amp; Conditions of the Apple Developer Program. Once your app is fully compliant, resubmit your app for review.Submitting apps designed to mislead or harm customers or evade the review process may result in the termination of your Apple Developer Program account. Review the Terms &amp; Conditions of the Apple Developer Program to learn more about our policies regarding termination.If you believe your app is compliant with the App Store Review Guidelines, you may submit an appeal. Alternatively, you may provide additional details about your app by replying directly to this message. 译文:您好，谢谢您提供的信息。经过进一步的审查，我们发现了以下的拒绝:我们注意到，你的app或它的元数据可以通过APP内购买API以外的方式购买APP中的内容、服务或功能，这并不适合APP Store。这款应用的下一个提交可能需要更长的审查时间。下一个步骤-检查App Store内购买部分评审指南。-确保您的应用程序符合app Store评审指南的所有章节以及苹果开发者计划的条款和条件。-一旦你的应用完全兼容，重新提交你的应用进行审查。提交旨在误导、伤害客户或逃避审查过程的应用程序，可能会导致您的Apple Developer程序帐户被终止。查看Apple Developer Program的条款和条件，了解更多关于终止的政策。如果你认为你的应用程序符合app Store评审准则，你可以提出上诉。或者，您可以通过直接回复此消息来提供关于您的应用程序的其他详细信息。 解决方案￼一. 审核期间显示会员卡，让苹果审核员使用内购买的方式 购买会员，而不是使用内购以外的 方式购买,在此基础上还有以下两种处理方式选择1)被拒内容中已经发出警告：逃避审核规则，可能导致开发者帐号封禁；根据提示此次把第三方支付模块注释掉提交上线,审核通过后，再次打开第三方支付模块，以修复bug的名义上线面临问题： 导致首个版本短时间内无法使用第三方支付(微信,支付宝等) 2)保留第三方支付模块,添加一个实体商品(类似淘宝),使用微信支付方式;需要设计一个新的UI商品界面问题:时间成本比较高,业务逻辑繁琐 推荐方案1),我们是使用方案1)解决的问题. 二. 审核期间隐藏会员卡信息,审核通过后显示会员卡信息,并且不需要添加内购支付的逻辑,保留第三方支付模块代码. 面临问题:苹果审核可能会检测到第三方支付的相关库,譬如微信的sdk,支付宝的sdk.导致开发者帐号封禁 附上截图: 被拒(二)原文We noticed that your app is using consumable in-app purchase products as intermediary currency for the exchange of items that function as non-renewing subscriptions.Next StepsTo resolve this issue, please delete your consumable in-app purchase products, then create separate non-renewing subscription in-app purchase products for each item that the user would have exchanged those consumable products for. This product type matches the usage model for the products you are ultimately selling to your users.Note: The product type cannot be changed once an in-app purchase product has been created. Therefore, you will need to create a new in-app purchase product with the correct product type.To create new in-app purchases: Log in to iTunes Connect Click on “My Apps” Select your app Click on “Features” to create new in-app purchases Click Save Once you’ve completed all changes, click the “Submit for Review” button at the top of the App Version Information page.ResourcesMore information on in-app purchase product types is available in the In-App Purchase Programming Guide. 译文:我们注意到，您的应用程序正在使用可消费的内购产品作为交换项目的中介货币，这些项目的功能是不可更新的订阅。下一个步骤为了解决这个问题，请删除您的可消费应用内购买产品，然后为用户将这些可消费产品交换的每个项目创建单独的不可更新的应用内购买产品。该产品类型与您最终销售给用户的产品的使用模型相匹配。注意:在创建内购产品之后，不能更改产品类型。因此，您需要创建一个具有正确产品类型的应用程序内购买产品。创建新的应用内购买:-登录iTunes Connect。-点击“我的应用”—选择你的应用-点击“功能”来创建新的内购。—点击保存-完成所有更改后，点击App版本信息页面顶部的“提交审核”按钮。 解决方案根据提示解决就可以,删除掉appstore类型不正确(消费类型)的内购产品,然后重新创建正确类型(非续期订阅)的内购产品即可.]]></content>
      <categories>
        <category>发布上架</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP上架被拒日常(4)- 私有API - Software Requirements]]></title>
    <url>%2F2018%2F06%2F07%2FAPP%E4%B8%8A%E6%9E%B6%E8%A2%AB%E6%8B%92%E6%97%A5%E5%B8%B8(4)-%20%E7%A7%81%E6%9C%89API%20-%20Software%20Requirements%2F</url>
    <content type="text"><![CDATA[原文:Your app uses the “prefs:root=” non-public URL scheme, which is a private entity. The use of non-public APIs is not permitted on the App Store because it can lead to a poor user experience should these APIs changeContinuing to use or conceal non-public APIs in future submissions of this app may result in the termination of your Apple Developer account, as well as removal of all associated apps from the App StoreNext StepsTo resolve this issue, please revise your app to provide the associated functionality using public APIs or remove the functionality using the “prefs:root” or “App-Prefs:root” URL scheme.If there are no alternatives for providing the functionality your app requires, you can file an enhancement request. 译文:您的应用程序使用“prefs:root=”非公开URL组合，这是一个私有API。应用商店不允许使用非公有api，因为如果这些api发生变化，会导致糟糕的用户体验继续使用或隐藏私有API，在以后提交这个应用程序时，可能会导致你的苹果开发者账户被终止，并从应用商店中删除所有相关的应用下一个步骤要解决这个问题，请修改应用程序，使用公共api提供相关功能，或者删除使用“prefs:root”或“app - prefs:root”私有API相关功能。如果没有提供应用程序所需功能的替代方案，您可以提交增强请求。 解决方案:1)全局搜索项目中”prefs:root”关键词字眼,并将搜索到的结果分情况删除或者注释掉或者寻找替代方法;此外如果不放心私有API问题,可以查找项目中是否存在其他私有API,如有删除掉即可.此方法推荐!!!2)如果通过方法1)解决了私有API的问题,但是应用内相关功能却无法实现了,就给苹果提交请求,增加新的公有API!不过此方法漫长不一定能解决问题]]></content>
      <categories>
        <category>发布上架</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP上架被拒日常(3)- 误判为企业应用]]></title>
    <url>%2F2018%2F06%2F07%2FAPP%E4%B8%8A%E6%9E%B6%E8%A2%AB%E6%8B%92%E6%97%A5%E5%B8%B8(3)-%20%E8%AF%AF%E5%88%A4%E4%B8%BA%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原文:We found that your app is an in-house app, intended for employees or members of your organization. As such, it is not appropriate for the App Store.For information on distributing proprietary, in-house apps, please refer to the Apple Developer Enterprise Program. 译文:我们发现您的APP是一个公司内部APP,用于员工或您的组织成员。因此，它并不适合应用程序商店。有关分配专有的信息,企业内部应用程序,请参阅苹果开发者计划 解决方案:上一次APP被拒,回复的相关内容有些片面,导致苹果审核员认为应用是一个企业应用,不适合上架到应用商店,只需要解释清楚APP是提供给哪些人群使用,不仅仅是针对公司员工,还有除员工以外的大众用户群体,则可以解决此问题]]></content>
      <categories>
        <category>发布上架</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP上架被拒日常(2)- Data Collection and Storage]]></title>
    <url>%2F2018%2F06%2F07%2FAPP%E4%B8%8A%E6%9E%B6%E8%A2%AB%E6%8B%92%E6%97%A5%E5%B8%B8(2)-%20Data%20Collection%20and%20Storage%2F</url>
    <content type="text"><![CDATA[原文:Guideline 5.1.1 - Legal - Privacy - Data Collection and StorageWe noticed that your app requires users to register with personal information to access non account-based features. Apps cannot require user registration prior to allowing access to app content and features that are not associated specifically to the user.Please see attached screenshots for detailsNext StepsUser registration that requires the sharing of personal information must be optional or tied to account-specific functionality. Additionally, the requested information must be relevant to the features.Request a phone call from App ReviewAt your request, we can arrange for an Apple Representative to call you within the next three to five business days to discuss your App Review issue 译文:准则5.1.1 -法律-隐私保护-数据收集和存储我们注意到你的应用程序需要用户通过提交个人信息注册帐号来访问一些不基于帐户之上的功能特性。应用程序不能在允许访问与用户没有特定关联的应用程序内容和特性之前要求用户注册。详情请见附件截图接着下一步需要共享个人信息的用户注册必须是可选的，或者绑定到特定于帐户的功能。此外，所请求的信息必须与特性相关。请求App Review的电话根据您的要求，我们可以安排一位苹果代表在接下来的3到5个工作日内给您打电话，讨论您的应用程序审核问题。 复现步骤:游客状态,点击观看”被拒截图1”中的视频,因为涉及到视频用户授权需要用户信息,所以会弹登录注册页面 解决方案:1)在游客状态下,隐藏这些需要用户信息的相关内容,此方法比较推荐!!!2)如果隐藏实现比较繁琐的话,可以在苹果审核期间,程序内部默认一个用户cookie,从而使得游客状态访问相关信息不需要用户登录;审核通过后,使用真实帐号的cookie. 这个方法实现过程中需要注意不能改动现有其他功能的逻辑以及审核状态之间的转换,比较繁琐麻烦3)请求与app review电话联系,等待在未来3–5工作日内与审核人员电话沟通解释—-游客状态下,访问相关内容为何需要登录注册.如果不登录注册会出现什么问题.磨破嘴皮子说服审核员,考验沟通技术,看运气 附上截图:]]></content>
      <categories>
        <category>发布上架</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP上架被拒日常(1)- Information Needed]]></title>
    <url>%2F2018%2F06%2F06%2FAPP%E4%B8%8A%E6%9E%B6%E8%A2%AB%E6%8B%92%E6%97%A5%E5%B8%B8(1)-%20Information%20Needed%2F</url>
    <content type="text"><![CDATA[原文:Guideline 2.1 - Information NeededWe have started the review of your app, but we are not able to continue because we need additional information about your app.Next StepsTo help us proceed with the review of your app, please review the following questions and provide as much detailed information as you can. Does your app access any paid content or services? What are the paid content or services, and what are the costs? Do individual customers pay for the content or services? If no, does a company or organization pay for the content or services? - Where do they pay, and what’s the payment method? If users create an account to use your app, are there fees involved? How do users obtain an account?Once you reply to this message in Resolution Center with the requested information, we can proceed with your review. 译文:准则2.1 -所需的信息我们已经开始评估你的应用程序,但我们不能继续,因为我们需要更多的信息关于你的应用。下一步来帮助我们进行应用程序的审查,请检查以下问题,并提供尽可能多的详细信息应用程序访问付费内容或服务吗?付费内容或服务是什么?费用是什么?个人客户支付内容或服务?如果没有，公司或组织是否为内容或服务付费?他们支付,支付方式是什么?如果用户使用你的应用程序创建一个帐户,有涉及费用?用户如何取得帐户?一旦你回复这个消息在解决中心所请求的信息,我们可以开始你的审查。 解决方案:此一般出现在APP首次上线或者APP时隔一段时间提交一个大的更新版本时,按照译文所描述的,在问题中心的回复框里回复相关问题即可.不过也需要谨慎回复!!! 如果APP中涉及到付费内容/付费服务,并且使用了苹果的内购(iap)支付,或者APP干脆没有相关的付费内容/付费服务,则可以如实回答; 如果APP中含有付费内容/付费服务,但是不想使用内购(iap)支付给苹果分成,从而使用支付宝/微信/网银等第三方支付,则此处就需要编造一个善意的谎言,否定APP中的相关付费信息. 回复例句:Our Application without access to any paid digital content and services, so will not involve the issue of pay for content. Our Application Have registered entrance application, the user can get an APP account function through registration应用没有访问任何付费的数字内容或服务,所以更不会涉及到为内容付费的问题.应用有注册入口,用户可以通过注册功能获得一个APP账户]]></content>
      <categories>
        <category>发布上架</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[No accounts with itunes connect access have been found for the team "xxxx"]]></title>
    <url>%2F2018%2F03%2F26%2FNo%20accounts%20with%20itunes%20connect%20access%20have%20been%20found%20for%20the%20team%20%22xxxx%22%2F</url>
    <content type="text"><![CDATA[距离这一次打包发版很近的两三天前，xcode内配置文件和证书都正确无误，打包过程还很顺利！这次打包出现如下图的问题 在网上查找了好多相关问题的解决方法，都没能解决我遇到的问题；隔天在stackoverflow社区里，查找到了几个解决问题的方法，其中一个对我起到了很大的作用！Xcode 9 “no iTunes Connect account” error when uploading ####解决方案1采用little的解决方法 关闭xcode 终端执行命令rm -fr ~/Library/Developer/Xcode/DerivedData/ 重新打开Xcode，再次打包上传 ####解决方案2采用Jayprakash Dubey的解决方法 1.打包生成IPA应用包2.使用Application Loader 上传IPA文件！ 不过才用上述两个方法的前提就是 确保Xcode里配置的描述文件和证书没有过期/失效，可以按照博客中的方法去检查。点击首张图左下角的 Manage Accounts去添加设置帐号信息。 1. 你点add，删掉你的账号，再添加一次上去，重启Xcode再来一遍试试2. 检查你的证书、描述文件在开发者中心有没有过期，在Xcode有没有配置好3. 如果你此时要做的是提交App上架审核的操作，请你打开Xcode，按 command+逗号 检查你账号的身份，member，admin，还是agent，只有agent才有权限提交上架]]></content>
      <categories>
        <category>发布上架</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析collectionView的item间距]]></title>
    <url>%2F2018%2F03%2F13%2F%E6%B5%85%E6%9E%90collectionView%E7%9A%84item%E9%97%B4%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[ios开发中比较常用到的就是 tableView 和 collectionView，二者分别用于列表展示和 网格展示；由于tableView的易用性几乎每个APP都会用到; 相对tableView，collectionView使用起来比较繁琐，所以collectionView的使用不常见。但UICollectionView也有自身的特点，比如横向布局、多行或者多列(瀑布流)展示。 一、创建collectionView（collectionView控制器）12345(collectionView)- (instancetype)initWithFrame:(CGRect)frame collectionViewLayout:(UICollectionViewLayout *)layout(collectionView控制器)- (instancetype)initWithCollectionViewLayout:(UICollectionViewLayout *)layout ; 初始化类似tableView，设置delegate 和 datasource；不同于tablView初始化设置UITableViewStyle，而collctionView初始化设置UICollectionViewLayout（一般用它的子类UICollectionViewFlowLayout）。此处的UICollectionViewLayout是用于存储collectionView的一些布局属性：12345@property (nonatomic) CGFloat minimumLineSpacing;@property (nonatomic) CGFloat minimumInteritemSpacing;@property (nonatomic) CGSize itemSize;@property (nonatomic) UICollectionViewScrollDirection scrollDirection;@property (nonatomic) UIEdgeInsets sectionInset; cell间距的设置需要用到以上这些关键性属性。 二、布局协议 UICollectionViewDelegateFlowLayout 协议中有以下这几个和布局相关的方法123456- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath;- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section;- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section;- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section;- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section;- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section; 这几个方法的功能和UICollectionViewLayout的4个属性基本相对应：1.属性用于统一设置2.对象方法既可以统一设置，也可以区别设置 这几个方法名的区别在后半部分1xxxxx sizeForItemAtIndexPath:(NSIndexPath *)indexPath 等同于属性 itemSize；1xxxxx insetForSectionAtIndex:(NSInteger)section 等同于属性 sectionInset；1xxxxx minimumLineSpacingForSectionAtIndex:(NSInteger)section 等同于属性 minimumLineSpacing；1xxxxx minimumInteritemSpacingForSectionAtIndex:(NSInteger)section 等同于属性 minimumInteritemSpacing； 三、图文解析对应属性（针对不同滚动方向）gif中每个不同颜色代表不同的section 水平方向滚动的collectionView，竖直方向的间距是固定的：minimumInteritemSpacing指的是同一个section 内部item的竖直方向间隙；minimumLineSpacing指的是同一个section 内部 item的水平方向间隙； 竖直方向滚动的collectionView，水平方向的间距是固定的：minimumInteritemSpacing指的是同一个section 内部item的水平方向间隙；minimumLineSpacing指的是同一个section 内部 item的竖直方向间隙； 总结：minimumInteritemSpacing表示 同一个section内部间item的 和滚动方向垂直方向的间距； minimumLineSpacing指的是同一个section 内部 item 的滚动方向的间距；sectionInset指的是每个section内缩进；属性设置的每个section的内错进是相同的，都是正数。如果需要实现不同的setion的不同的内缩进，可以使用对象方法1- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section; 来实现。 注意：在写demo的过程中，发现collectionView的contentInsetAdjustmentBehavior（等同于控制器的automaticallyAdjustsScrollViewInsets属性）默认为UIScrollViewContentInsetAdjustmentAutomatic枚举值，会自适应控制器的边距，避开导航栏和状态栏，而使得collectionView的真实高度 和设置的高度不一致（相差状态栏和导航栏的高度和）。 demo地址：https://github.com/NightSkyWatchers/collectionView，欢迎下载观摩指正，内有*彩蛋*]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件生命周期&&测试的工作流程]]></title>
    <url>%2F2018%2F03%2F01%2F%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%26%26%E6%B5%8B%E8%AF%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[软件的生命周期1.问题定义及规划解决用户的痛点，方便用户软件开发目的以及可行性，制定开发计划。。。 2.需求分析3.软件设计4.软件编码开发人员进行程序编码 5.软件测试开发做，单元测试开发or测试做， 集成测试开发做， 系统测试测试做，验收测试 6.软件维护版本上线，产品上线，版本的升级改造，修复bug 软件测试的工作流程接触到哪些岗位人员———-开发人员、产品经理、客服（收集用户反馈）、实施／技术支持／现场实施（驻场）、设计师]]></content>
      <categories>
        <category>技术拓展</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习---软件测试的分类]]></title>
    <url>%2F2018%2F03%2F01%2F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0---%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1.按照测试阶段单元测试，集成测试，系统测试，验收测试（正式验收测试，Alpha测试，Beta测试） 集成测试——-开发与开发之间的联调，接口测试系统测试——整体全部功能的测试，不是模块的测试Alpha测试—–前期用户测试，内部人员模拟实际环境进行验收测试（内测）Beta测试——后期用户测试，通过内部测试，即将正式发布。 在一个或多个真实环境下发布版本进行公测。（预发步版本，公测，预测） 2.按照测试技术分类白盒测试，黑盒测试，灰盒测试 白盒测试———- 知道程序内部代码逻辑，代码拿过来，输入测试数据就知道是否ok黑盒测试———-不知道xxxxxxxxxxxx，通过表面的反应才知道是否ok灰盒测试———-介于二者之间，既有xx，也有xx 3.按照被测试对象是否运行分类动态测试，静态测试（文档检查，代码走查，界面检查） 4.不同测试手段手工测试，自动化测试 5.按测试包含的内容划分功能测试，界面测试，安全测试，兼容性测试，易用性测试，性能测试，压力测试，负载测试，恢复测试（灾备） 恢复测试—-主要检查系统的容错能力。采用各种办法强迫系统失败，然后验证系统能否在指定的时间间隔内尽快恢复并重新启动系统易用性测试—-测试软件是否易用，主观性比较强 6.其他测试冒烟测试，回归测试，探索性测试（测试思维） 详解：冒烟测试——在真正测试开始之前，都会对应用版本 主干功能做一下测试，如果主干功能都测试不通过，就可以打回这个版本； 回归测试——-指之前提出的bug被修正后／软件功能发生变化后进行的重新测试，确认修改部分已经ok，并且不会对其他功能造成影响！1.验证bug是否被修复2.和该bug相关功能是否被影响 ###软件测试是什么定义：为了发现程序中的错误而执行程序的过程 1.为了发现程序存在的代码或业务逻辑错误2.为了检验产品是否符合用户需求3.为了提高用户的体验 软件测试的原则1.测试应该尽早介入2.所有测试追溯到用户需求3.程序员英国避免检查自己的程序，除了单元测试，交给第三方／专业测试4.设计测试用例时，应该考虑合法的输入和不合法的输入以及各种边界条件，意外状态5.二八原则，测试发现的错误中80%很可能起源于20%的模块中（聚集效应，bug比较集中）6.对错误结果要进行一个确认过程（必现，偶现；复现！！！）7.制定严格的测试计划8.完全测试是不可能的，测试需要终止（测试不是无休止的，没有明显bug测试就可以终止）9.妥善保存测试过程中的所有文档]]></content>
      <categories>
        <category>技术拓展</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享与支付中的磕磕碰碰]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%88%86%E4%BA%AB%E4%B8%8E%E6%94%AF%E4%BB%98%E4%B8%AD%E7%9A%84%E7%A3%95%E7%A3%95%E7%A2%B0%E7%A2%B0%2F</url>
    <content type="text"><![CDATA[1.分享菜单栏汉化使用ShareSDK自带的UI分享界面，出现英文的分享界面！在cocopods中，能看到ShareSDK是有中英文名称的（国际化） 所以只需要在项目的info.plist文件中增添一个 “Localizations”字段，并添加一个 “chinese (simplified)”即可切换为想要的汉化名称。 ##2.分享微信– bundle id验证不通过 部分手机分享不正常,(ios9，ios10 OK, ios11.2出现此问题)这是微信有段时间开始验证项目的bundle id相关信息，1)去微信的开放平台(https://open.weixin.qq.com)查看注册的应用是否包含ios平台，如若不包含ios平台，请添加！！ 2)注册的应用的bundle id 和项目的bundle id是否一致，如果不一致，修改一致！ 3.微信支付，调不起微信App可能存在的问题1）123456789//调起微信支付PayReq* req = [[PayReq alloc] init];req.partnerId = model.partnerId;req.prepayId = model.prepayId;req.nonceStr = model.nonceStr;req.timeStamp = model.timeStamp;req.package = model.package;req.sign = model.sign;[WXApi sendReq:req]; 这些是调起微信app的关键值，如果这些值中任何一个值不存在都会发生调不起微信app的可能！]]></content>
  </entry>
  <entry>
    <title><![CDATA[打上全局断点就崩溃在main函数上]]></title>
    <url>%2F2017%2F11%2F30%2F%E6%89%93%E4%B8%8A%E5%85%A8%E5%B1%80%E6%96%AD%E7%82%B9%E5%B0%B1%E5%B4%A9%E6%BA%83%E5%9C%A8main%E5%87%BD%E6%95%B0%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[不打全局断点能正常运行，打上全局断点就崩溃在main函数或者应用的其他莫名其妙的位置可能原因1. 当前应用在播放音视频文件，点击继续运行就可以了2. 项目里面用了C++或者其他语言写的东东,可能会这样,all exceptions就表明,所有exceptions都会被catch,即使这个exception在代码里已经处理了的,也会被catch,高亮.如果是因为C++导致的,你可以右键点击all exceptions编辑将exception-&gt;all改为objective-c.如果不是这个原因,那你也不用管.]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装mysql(Mac)]]></title>
    <url>%2F2017%2F11%2F10%2F%E5%AE%89%E8%A3%85mysql(Mac)%2F</url>
    <content type="text"><![CDATA[1.从官网下载dmg格式的安装包 2.双击下载的安装包，按‘‘继续’’/‘‘同意’’直到最后安装完成 3.为了方便使用，设置全局变量打开终端（Terminal）,1)cd ~ 2)如果没有 .bash_profile文件，会创建该文件touch .bash_profile 3)打开并编辑.bash_profile文件open .bash_profile 使用文本编辑器打开 .bash_profile文件或者 vi .bash_profile 直接在终端界面编辑 .bash_profile文件 4)在.bash_profile文件中添加路径export PATH=${PATH}:/usr/local/mysql-5.6.38-macos10.12-x86_64/bin路径中 mysql-5.6.38-macos10.12-x86_64和下载的安装包的名称保持一致5) 保存并关闭.bash_profile文件文本编辑器打开—保存(command+s) 关闭(command+w)终端编辑的打开————-输入:wq 6)更新刚配置的环境变量source .bash_profile 4.启动mysql服务器打开系统偏好设置——&gt;Mysql——&gt;Start Mysql Sever 5.登录终端输入mysql -u root -p会提示输入密码，如果没设置过密码就直接按enter略过；当看到 Welcome to the MySQL monitor.xxxxxx字样，表示登录成功]]></content>
      <categories>
        <category>技术拓展</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+git一步一坑搭建博客]]></title>
    <url>%2F2017%2F08%2F07%2Fhexo-git%E4%B8%80%E6%AD%A5%E4%B8%80%E5%9D%91%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[根据这篇文章使用hexo+git搭建真正属于自己的博客的过程中是很顺利的,但是还是在部署到远程仓库的时候还是遇到了以下几个问题:1234deploy:type:gitrepository: git@github.com:xxxxxx.githup.io.gitbranch: master 1.修改了配置_config.yml文件之后,执行部署命令 hexo g/ hexo s,报错如下:12FATAL bad indentation of a mapping entry at line 81, column 13:repository: https://github.com/NightSkyWat ... 原因:hexo语法比较严格,在修改配置文件_config.yml之后,一定要检查冒号后面的空格!!!检查冒号后面的空格!!!检查冒号后面的空格!!! 解决:将修改部分type/repository/branch后面都有一个空格 2.修改问题1之后,执行部署命令hexo d,报错如下:1ERROR Deployer not found: git 原因:部署远程博客前，需要安装git解决:执行该命令 npm install hexo-deployer-git --save 3.使用SSH KEY,本地生成id_rsa 和id_rsa_pub文件,并复制id_rsa_pub文件中的内容添加到帐号之后,部署(hexo d)报错:12345Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html 测试当前的SSH是否配置成功,在git bash 中执行命令ssh -T git@github.com报错如下:Permission denied (publickey). 原因:说明当前SSH没有配置成功 解决:请确保以下2步均做到1、远程服务器已经有了对应于本地主机上公钥2、本地主机ssh服务开启(windows上是ssh-agent.exe运行)，并且本地主机私钥要包含在ssh服务列表中 第一步已经完成,:已经将id_rsa_pub文件中的内容添加到了github帐号 检查本地私钥是否存在于ssh服务中12cd ~/.ssheval &apos;ssh-agent -s&apos; 如果运行这句出现Could not open a connection to your authentication agent，那么就先运行ssh-agent bash再运行ssh-add -l如果不存在，需要添加进去ssh-add ~/.ssh/id_rsa添加完成之后,再执行ssh -T git@github.com测试SSH是否配置成功!!! 如果出现以下内容说明配置成功12Hi username! You&apos;ve successfully authenticated,but GitHub does not provide shell access. 4.执行终端命令hexo s,并在浏览器里输入https://localhost:4000后,可以预览到修改的相关内容,但是部署到远程仓库后(成功部署),打开对应的http://username.githup.io网址却出现以下充斥着形形色色广告的界面,到底是什么原因导致的呢?最后经过排查找出错误原因:因为自己错误的拼写习惯,错把github拼成了githup,修改了 userName.github.io 和 _config.yml中repository:键值之后,顺序执行 hexo clean / hexo g /hexo d命令重新部署到远程仓库, 并进入对应的 http://username.github.io ###大功告成!!! 参考github设置添加SSHPermission denied (publickey)Hexo博客搭建中的坑5分钟 搭建免费个人博客]]></content>
      <categories>
        <category>技术拓展</category>
      </categories>
      <tags>
        <tag>jss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梳理易引起retain-cycle的场景(使用block)]]></title>
    <url>%2F2017%2F08%2F03%2F%E6%A2%B3%E7%90%86%E6%98%93%E5%BC%95%E8%B5%B7retain-cycle%E7%9A%84%E5%9C%BA%E6%99%AF(%E4%BD%BF%E7%94%A8block)%2F</url>
    <content type="text"><![CDATA[开发以及面试中,经常涉及到使用block的需要注意的问题—-循环引用,趁此时机梳理相关block引起循环引用的场景: 使用通知(notification) 系统自带的block方法,在block中使用self–&gt;会发生循环引用1234567891011121314151617181920212223TwoVC .m文件-(void)dealloc &#123;NSLog(@&quot;%s&quot;,__func__);&#125;- (void)viewDidLoad &#123;[super viewDidLoad];self.view.backgroundColor = [UIColor orangeColor];// Do any additional setup after loading the view.//__weak typeof(self) weakSelf = self; //弱引用[[NSNotificationCenter defaultCenter] addObserverForName:@&quot;testBlock&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;//__strong typeof(self) strongSelf = weakSelf;NSDictionary *userInfo = note.userInfo;NSLog(@&quot;userInfo--%@ -- self.view - %p&quot;,userInfo,self.view);&#125;];&#125;- (void)viewWillDisappear:(BOOL)animated &#123;[super viewWillDisappear:animated];[[NSNotificationCenter defaultCenter] removeObserver:self];NSLog(@&quot;%s&quot;,__func__);&#125; 控制台输出12342017-08-02 17:09:31.131 testBlock[36251:3586073] userInfo--&#123;Project = testNotificationBlock;&#125; -- self.view - 0x7fff0b5019802017-08-02 17:09:34.073 testBlock[36251:3586073] -[TwoVC viewWillDisappear:] ######结论: 当前VC没有被释放,添加弱引用后,VC被释放掉;存在retain-cycle 使用MJRefresh框架中返回上下拉刷新的block方法,在block中使用self–&gt;会发生循环引用123456789101112131415161718192021222324252627282930ThreeVC .m文件-(void)dealloc &#123;NSLog(@&quot;%s&quot;,__func__);&#125;- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view.self.view.backgroundColor = [UIColor whiteColor];self.tableView = [[UITableView alloc] initWithFrame:self.view.bounds style:UITableViewStylePlain];[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@&quot;cell&quot;];self.tableView.dataSource = self;// __weak typeof(self) weakSelf = self;//(弱引用)self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123;// __strong typeof(self) strongSelf = weakSelf;NSLog(@&quot;MJrefresh --下拉刷新&quot;);[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;testBlock&quot; object:nil userInfo:@&#123;@&quot;Project&quot;:@&quot;testNotificationBlock&quot;&#125;];[self endrefresh];&#125;];[self.tableView.mj_header beginRefreshing];[self.view addSubview:self.tableView];&#125;- (void)viewWillDisappear:(BOOL)animated &#123;[super viewWillDisappear:animated];NSLog(@&quot;%s&quot;,__func__);&#125; 控制台输出123452017-08-03 10:39:44.381 testBlock[37278:3717266] MJrefresh --下拉刷新2017-08-03 10:39:44.382 testBlock[37278:3717266] userInfo--&#123;Project = testNotificationBlock;&#125; -- self.view - 0x7f87474064402017-08-03 10:39:55.641 testBlock[37278:3717266] -[ThreeVC viewWillDisappear:] ######结论: 当前VC没有被释放,添加弱引用后,VC被释放掉;存在retain-cycle 3.强引用自定义的属性block,并在block中使用self–&gt;,会引起循环引用123456789101112131415/** block */@property (nonatomic, copy) void(^myblock)();@end@implementation FourVC- (void)viewDidLoad &#123;[super viewDidLoad];self.view.backgroundColor = [UIColor yellowColor];_myblock = ^ &#123;NSLog(@&quot;--%p&quot;,self.view);&#125;;_myblock();&#125; 控制台输出122017-08-03 11:17:51.409 testBlock[37510:3750978] --0x7f8e7d70b4602017-08-03 11:17:55.696 testBlock[37510:3750978] -[FourVC viewWillDisappear:] ######结论: 1)报警告 2)当前VC没有被释放,添加弱引用后,VC被释放掉;存在retain-cycle 未完待续,欢迎指正/添加测试代码奉上]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[block中成员变量和属性的区别]]></title>
    <url>%2F2017%2F07%2F28%2Fblock%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[person模型 123456789101112.h文件#import &lt;Foundation/Foundation.h&gt;@interface person : NSObject/** block */@property (nonatomic, copy) void(^ageBlock)(int age);@end.m文件#import &quot;person.h&quot;@implementation person@end testVC 123456789101112131415.m文件#import &quot;person.h&quot;#import &quot;testViewController.h&quot;@interface testViewController ()/** person */@property (nonatomic, strong) person *p;/** value */@property (nonatomic, assign) int value;@end@implementation testViewController &#123;int _value;&#125; ####属性1.在生成对应的成员变量_value的同时;2.也会自动生成setter/getter方法.使用self.value实际在调用两个方法来实现对变量的操作. 测试代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546-(void)dealloc &#123;NSLog(@&quot;释放当前vc对象&quot;);&#125;- (void)viewDidLoad &#123;[super viewDidLoad];self.p = [[person alloc] init];__weak typeof(self) weakSelf = self;self.p.ageBlock = ^(int age) &#123;//1.1 成员变量写法(自动报警,提示会产生循环引用)_value = 50;NSLog(@&quot;_value-----%d&quot;,_value);// 1.2等价成员变量(自动报警,提示会产生循环引用)self-&gt;_value = 30;NSLog(@&quot;self-&gt;_value---%d&quot;,self-&gt;_value);// 1.3成员变量弱引用(报错)//weakSelf-&gt;_value = 20;//NSLog(@&quot;weakSelf-&gt;_value----%d&quot;,weakSelf-&gt;_value);// 1.4成员变量weak-strong dance__strong typeof(self) strongSelf = weakSelf;strongSelf-&gt;_value = 10;NSLog(@&quot;strongSelf-&gt;_value--%d&quot;,strongSelf-&gt;_value);//2.1属性未弱引用写法(自动报警,提示会产生循环引用)self.value = 50;NSLog(@&quot;%d&quot;,self.value);//2.3 属性的写法(由成员变量可以类推到也会有风险,推荐使用weak-strong dance方式)weakSelf.value = age;NSLog(@&quot;%d&quot;,weakSelf.value);//2.3 属性的写法(weak-strong dance)__strong typeof(self) strongSelf = weakSelf;strongSelf.value = age;NSLog(@&quot;%d&quot;,strongSelf.value);&#125;;&#125;self.p.ageBlock(10); 几种写法最终测试结果如下123456789101112131415161718192021222324252627281.1 没有释放当前vc,说明当前vc继续被强引用,没有被销毁2017-07-28 15:02:25.114 test_Property[20484:1869126] _value-----102017-07-28 15:02:26.325 test_Property[20484:1869126] -[testViewController viewWillDisappear:],控制器pop出去1.2 没有释放当前vc,说明当前vc继续被强引用,没有被销毁2017-07-28 15:13:12.727 test_Property[20539:1878132] self-&gt;_value---102017-07-28 15:13:14.764 test_Property[20539:1878132] -[testViewController viewWillDisappear:],控制器pop出去1.3 见下面 xcode自测报错图1.4 释放当前vc,并被销毁2017-07-28 15:17:27.160 test_Property[20568:1883004] strongSelf-&gt;_value--102017-07-28 15:17:28.627 test_Property[20568:1883004] -[testViewController viewWillDisappear:],控制器pop出去2017-07-28 15:17:29.131 test_Property[20568:1883004] 释放当前vc对象2.1 没有释放当前vc,说明当前vc继续被强引用,没有被销毁2017-07-28 15:19:04.250 test_Property[20583:1884117] 102017-07-28 15:19:05.301 test_Property[20583:1884117] -[testViewController viewWillDisappear:],控制器pop出去2.2 释放当前vc,并被销毁2017-07-28 15:21:50.294 test_Property[20621:1886605] 102017-07-28 15:21:51.488 test_Property[20621:1886605] -[testViewController viewWillDisappear:],控制器pop出去2017-07-28 15:21:51.994 test_Property[20621:1886605] 释放当前vc对象2.3 释放当前vc,并被销毁2017-07-28 15:22:52.713 test_Property[20637:1887821] 102017-07-28 15:22:54.250 test_Property[20637:1887821] -[testViewController viewWillDisappear:],控制器pop出去2017-07-28 15:22:54.756 test_Property[20637:1887821] 释放当前vc对象 Capturing &#39;self&#39; strongly in this block is likely to lead to a retain cycle Dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to strong variable first 简单翻译一个SO的答案：Why would you use an ivar?，展开说一下成员变量的好处。 封装如果成员变量是private，程序中的其它对象很难直接访问该成员变量。如果是属性，相对更容易用父类方法读写属性。 性能成员变量地址可以根据实例的内存地址偏移寻址。而属性的读写都需要函数调用，相对更慢。 非基础类型对于复杂的C++类型，往往设为成员变量更合适，也许这种类型不支持copy，或者完全复制很麻烦。 多线程多线程环境下，为保证数据一致性，在需要同步执行的代码段更应该使用成员变量。如果对需要同步更新的数据用getter/setter 方法，数据更新效率低，会带来更多的获取锁请求失败。 程序正确性成员变量可以做直观的内存管理。属性可以一层层继承，还可以复写。容易出错。 二进制文件的体积默认用属性，会生成不必要的getter/setter 方法，程序体积会变大。 注意:在block中最好使用属性,并使用weak-strong dance弱引用使用成员变量(_value)常常忽略掉前面的self指针,容易产生循环引用的,泄露内存; 参考文章:属性(property)与成员变量(ivar)有什么区别iOS中self.和下划线的区别]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A nested bundle contains simulator platform listed in xxxx Info.plist key]]></title>
    <url>%2F2017%2F05%2F24%2FA%20nested%20bundle%20contains%20simulator%20platform%20listed%20in%20xxxx%20Info.plist%20key%2F</url>
    <content type="text"><![CDATA[应用审核被拒,原因: Invalid Bundle - A nested bundle contains simulator platform listed in CFBundleSupportedPlatforms Info.plist key. 分析: 内嵌的路径 里的info.plist 文件中 一个 CFBundleSupportedPlatforms 值 包含了” 模拟器平台”, 众所周知,提交审核上架的应用是不能包含模拟器的架构和平台的,所以根据问题描述针对性解决. 解决: 内嵌路径(一般为第三方的库中)找到plist文件中的 CFBundleSupportedPlatforms删除支持的模拟器平台 查找方法如下:(仅供参考) 图1 图2]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动发布应用无法上架]]></title>
    <url>%2F2017%2F05%2F24%2F%E6%89%8B%E5%8A%A8%E5%8F%91%E5%B8%83%E5%BA%94%E7%94%A8%E6%97%A0%E6%B3%95%E4%B8%8A%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[beta最新版0.5提交苹果的审核通过了,手动发布后不久却收到邮件提示: 该应用已经被开发人员下架! 原因: 之前上架了一个beta低版本,并且被同事下架了; 手动发布beta 0.5 的时候没有将应用的 销售范围 仍为 “下架”状态 下架应用解决方法:修改为 “在所有地区供应”即可 重新上架应用图 苹果开发指南中有提到相关问题,描述如下: 注意： 如果您将某个版本下架，然后添加了一个新版本，则新版本也会处于“被下架”状态，即使新版本已获得“App 审核”批准也是如此。若要发行新版本，您需要再次使 App 获准销售。 将 App 重新上架 在“App 详细信息”页面，点按“价格与销售范围”。 在“销售范围”部分，选择“在所有地区供应”选项。 ../Art/13D-RemovedAppAvailable_2x.png 点按“存储”。 App 状态从“被开发人员下架”更改为“可供销售”。24 小时内您的 App 会重新显示在商店中。 其他问题请参考 苹果itunes connect 开发指南]]></content>
      <categories>
        <category>发布上架</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频播放支持横屏]]></title>
    <url>%2F2017%2F05%2F15%2F%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%94%AF%E6%8C%81%E6%A8%AA%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[应用整体只支持竖屏，只有特定的某个界面支持横屏 解决方法： 1.在项目中plist文件中设置支持转屏方向 转屏控制级别： tabar&gt;导航控制器&gt;普通控制器 2.在tabbar/ 导航控制器/ 普通控制器 的.m文件中 复写以下三个方法 12345- (BOOL)shouldAutorotate ； // 是否支持屏幕自动旋转-(UIInterfaceOrientationMask)supportedInterfaceOrientations // 支持的转屏方向-(UIInterfaceOrientation)preferredInterfaceOrientationForPresentation // 进入后默认的屏幕方向（必须包含在支持的屏幕方向里） 1）TabBarVC 中重写三个方法的代码如下：1234567891011121314151617- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;return self.selectedViewController.supportedInterfaceOrientations;&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123;return self.selectedViewController.preferredInterfaceOrientationForPresentation;&#125;- (BOOL)shouldAutorotate &#123;return self.selectedViewController.shouldAutorotate;&#125; 2）导航控制器基类中重写三个方法的代码如下：1234567891011121314151617- (BOOL)shouldAutorotate&#123;return self.topViewController.shouldAutorotate;&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;return self.topViewController.supportedInterfaceOrientations;&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123;return self.topViewController.preferredInterfaceOrientationForPresentation;&#125; 3）普通控制器基类中代码如下：1234567891011121314151617- (BOOL)shouldAutorotate &#123;return NO;&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;return UIInterfaceOrientationMaskPortrait;&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123;return UIInterfaceOrientationPortrait;&#125; 针对没有tabbar，只有导航控制器的应用，可以直接省去TabBarVC中方法重写代码； 3.因为项目的大多控制器是不支持自动转屏，且只支持竖屏；因此这些ViewController 继承自BaseViewController； 针对特定的需要支持 左右横屏的视频播放界面，仍需要复写以上三个方法12345678910111213141516171819202122232425262728293031323334353637@property(nonatomic,assign)BOOL autoRotate;- (BOOL)shouldAutorotate&#123;return self.autoRotate;&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123;return UIInterfaceOrientationPortrait;&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;return UIInterfaceOrientationMaskAllButUpsideDown;&#125;旋转屏幕- (void)switchToLandscapePotrait &#123;_autoRotate = YES;// 如果当前设备是物理横屏,先恢复为竖屏,保证后面有转屏动画if ([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft) &#123;[[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:UIDeviceOrientationPortrait] forKey:@&quot;orientation&quot;];&#125;// 手动设置横屏,会调用 方法 shouldAutorotate[[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:UIDeviceOrientationLandscapeLeft] forKey:@&quot;orientation&quot;];[UIApplication sharedApplication].statusBarHidden = YES;_autoRotate = NO;&#125; 代码手动设置横屏, [ [UIDevice currentDevice] setValue: forKey: ]会调用 方法- (BOOL)shouldAutorotate,如果该方法返回的是NO,则无法使用代码设置横屏; 所有需要在调用前 设置_autoRotate = YES; 调用完毕设置_autoRotate = YES; 注意事项: 当手机横放,已经是物理横屏的时候,再手动设置横屏是无效的;所以此处需要做处理(如果是物理横屏,先恢复为物理竖屏)]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存之NSCache&NSDictonary]]></title>
    <url>%2F2017%2F05%2F07%2F%E7%BC%93%E5%AD%98%E4%B9%8BNSCache%26NSDictonary%2F</url>
    <content type="text"><![CDATA[实现缓存: NSCache相比NSDictonary: 1)多数情况下,可以使用objectForKey: / setObject: forKey: /removeObjectForKey: 2)拥有多线程安全的特性,可以在任何线程上不加锁地修改NSCache; 3)还被设计为能与符合协议的对象整合,开发者可以通过调用 beginContentAccess 和 endContentAccess 控制何时丢弃对象是安全的 4)能在应用运行时/应用暂停时 提供自动缓存管理；也会在使用的常见类型NSurgreableData后， iOS会释放内存(即使应用处于暂停状态)。 —————————————-分割线—————————————— 图层绘制:（CALayer和UIView） UIView是一个相当重量级的对象，它管理绘制与事件处理(尤其是触摸事件)。CALayer完全关乎绘制。事实上，UIView依靠CALayer来管理绘制，这样两者就能协作的很好。图层会在它的contents属性中绘制任意东西，开发者负责进行设置。 方法一：直接分配 UIImage *image = …; CALayer *layer = …; layer.contents = (id)image.CGImage; 方法二：core Animation会按照以下顺序通过CALayer和委托方法来创建它。 1）[CALayer setNeedsDisplay] : 代码需要调用它。它会将图层标记为需要重绘的，要求通过列表中的步骤来更新contents。除非调用了setNeedsDisplay方法，房子contents属性永远不会更新。 2）[CALayer displayIfNeeded] ：绘制系统会在需要时自动调用它。如果图层通过被调用setNeedsDisplay标记为需要重绘的，绘制系统就会接着执行后续步骤。 3）[CALayer display]: displayIfNeeded方法会在合适的时候调用它。开发者不应该直接调用它，如果实现了委托方法，默认实现会调用displayeLayer： 委托方法。否则，display方法会调用drawInContext:方法。可以在子类中覆盖display方法以直接设置contents属性 4）[delegate displayLayer: ] :默认的[CALayer display]会在方法实现这个方法时调用它。它的任务是设置contents。如果实现了这个方法（即使没有什么操作），后面就不会运行自定义的绘制代码。 5）[CALayer drawInContext:] :默认的display方法会创建一个视图图形上下文并将其传给drawInContext： 方法。它与UIView drawRect：方法相似，但不会自动设置UIKit上下文。为了使用UIKit来绘图，你需要调用UIGraphicsPushContext（）方法指定接收到的上下文为当前上下文。否则，他只会使用Core Graphics在接收到的上下文中绘图。默认的display 方法获取最终的上下文，创建一个CGImage并将其分配给contents。默认的CALayer drawInContext：] 会在方法已实现时调用【delegate drawLayer： inContext】。否则，就不执行任何操作。不过可以直接调用这个方法 6）[delegate drawLayer: inContext:]： 如果实现了这个方法，默认的drawInContext：会调用这个方法实现更新上下文，从而是display方法可以创建CGImage。 总结：使用drawInContext：方法是设置contents的另一种方法。它是通过display方法调用的，而display 方法只有当你通过 setNeedsDisplay 方法明确标记图层为需要重绘是调用。 drawInContext：只在当前图层绘制（不包括期任何子图层）。要绘制图层及其子图层，可以使用renderInContext：方法，它可以捕捉图层当前动画的状态。renderInContext：使用当前渲染的状态（由Core Animation内部管理），因此它不会调用drawInContext：方法。]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友盟推送那些问题(iOS10)]]></title>
    <url>%2F2017%2F02%2F19%2F%E5%8F%8B%E7%9B%9F%E6%8E%A8%E9%80%81%E9%82%A3%E4%BA%9B%E9%97%AE%E9%A2%98(iOS10)%2F</url>
    <content type="text"><![CDATA[上周，公司要实现推送通知的功能，并决定在项目中集成友盟推送的 SDK来代替之前集成的云巴推送。 云巴推送是什么鬼？让我们来看看它的功能和使用场景。 云巴是一个覆盖全国（即将覆盖美国欧洲）的实时消息发布订阅系统，可以以毫秒级的速度向百万乃至千万终端用户发送大量的消息。云巴适用于对实时性和到达率要求高的应用、游戏、设备。云巴支持手机、平板、笔记本、智能硬件、智能家居等作为终端。 云巴在 Github 上开源地址，云巴使用轻量级的 MQTT 作为协议，主要编程语言为 Erlang。云巴支持 IOS, Android, JavaScript, Socket.IO, PHP, C, C#等语言，可以从任一终端向另一终端发送消息。 云巴的特点是：高并发、低耗费、毫秒级、跨平台、跨设备、跨语言。 云巴的应用场景包括：双向消息推送，私信，即时聊天，多人大型游戏，租车打车通知，远程摄像头控制，远程开关空调，实时更新股票走势，实时更新库存量，活动文字直播，实时地理位置地图，智能硬件的 APP 控制，实时统计图表。 其实云巴和友盟在实现推送功能方面没什么太大区别，只是因为云巴推送是在项目赶工期时的产品，具体的交互界面以及参数都没来得及定！所以推送在本次开发任务中交给了不大熟知云巴的我来做，因此换成了被大家熟悉且曾经集成过的友盟推送！ 下面介绍一些集成中常出的问题以及自己出现的问题： 1.友盟后台添加新应用，需要上传 P12文件，而 pem 文件是不能上传成功的（本人没有上传成功） 本人从钥匙串中导出文件是只能导出为 pem 文件，但是导出的 pem 文件却不能被友盟后台识别转换 后来发现所导出的证书下面缺少了私钥，并且左侧没有三角标识，如下图： 于是使用公司的苹果开发者帐号里面重新生成了一套 SSL证书（包含私钥，呈现下三角标识），如下图： 左侧的三角标识显示为上图状况时，导出的p12文件才是友盟后台所需要的证书文件（而非钥匙串的 p12文件），把导出的 p12文件（设置密码*）上传到友盟后台，并在相应位置输入刚才设置的相对应证书的密码即可添加应用成功； 随后就可以在 应用信息 一栏中查看应用刚刚添加的应用的 Appkey 和 AppMaster Secret，并可以设置公司推送服务器的IP 地址 2.通过 DeviceToken在友盟后台添加测试设备 查看友盟官方相关deviceToken问题的论坛 2.11）使用didRegisterForRemoteNotificationsWithDeviceToken：（NSData *）token获取 token并使用 NSLog 方法打印出来，但是打印出来的 token 如下图： 2.22）此时把以上字符串复制粘贴到图2.1的空格中，会标红报错——Device Token不能包含特殊字符， 分析原因得知：刚才拷贝的内容包含尖括号&lt;&gt;以及空格，所以处理办法是——去掉&lt;&gt;和空格后； 3）根据上一步分析，在图2.1空白处将拷贝的内容修改过后，发现仍然报错——Device Token长度错误 分析原因得知：第一步拷贝到2.1图中空白处的内容因为包含空格和尖括号，所以长度已经超出了64，达到了73，而空白处提示 “输入64位*“，所以此处拷贝过来的内容已经被截取了前64位，导致后面的一些字符串被删除掉了，即使删除了尖括号和空格，就会导致被自动截取的前64位中有效的字符串（非空格，非尖括号）不足64位， 所以最有效的处理方法就是———从 1）中拷贝的 token 去除尖括号以及空格 于是获取 token 的方法就使用如下方法： DeLog(@”UmengDeviceToken-%@”,[[[[deviceToken description] stringByReplacingOccurrencesOfString: @”&lt;” withString: @””] stringByReplacingOccurrencesOfString: @”&gt;” withString: @””] stringByReplacingOccurrencesOfString: @” “ withString: @””]); 4）通过3）获取的 token 拷贝粘贴到空白处，并填写设备名称加以区分，即可添加成功测试设备。 3.友盟后台测试单播和自定义播（alias）都能成功，而公司服务器测试单播可成功，而 alias 报2010错误 查看友盟与Alias对应的Device_token 为空的官方论坛 &amp;&amp; 单播可收到，广播收不到的官方论坛 1）检查 iOS 客户端代码是否设置别名成功 客户端设置别名（Alias）代码如下： [UMessage setAlias:@”alias1310” type:@”alias” response:^(id _Nonnull responseObject, NSError * _Nonnull error) { DeLog(@”成功返回数据–%@”,responseObject); }]; 并且打印信息显示：成功返回数据–{success = ok} 2）通过友盟后台的工具检测设置的 alias 是否成功 3）因为安卓都 OK，考虑到安卓和 iOS 的后台是分开集成的，所以让后台人员配合检查其后台相关代码 后台人员检查无误！！！ 4)闹心有木有，到底哪里出了问题呢？？ 有点信不过后台哥们，于是跑到后台看他们的代码以及相关文档如下： 他们也有个 alias_type:”xx”，阅读后面描述发现端倪，于是查看后台代码中alias_type 值发现：我的代码中的 type 类型值 和后台的竟然没有统一写成一致的，是不是这个问题导致的呢？？？ 于是飞速再键盘上敲下了相同的 alias_type 值，经过测试发现 OK 啦！ 报的错误和真正的问题根源还是不大一样的！哦耶 4.自定义弹框偶尔 会弹出两个弹框——自定义的弹框+友盟的默认弹框 这个问题最初没有发现，后来有一次做断点调试的过程中，发现：两个弹框的Bug必现！！！！！ 1）因为测试机是 iOS10以下系统，所以在方法 代理方法 didReceiveRemoteNotification： fetchCompletionHandler： 中查看是否关闭友盟弹框 如果是 iOS10系统，需要再方法userNotificationCenter： willPresentNotification： withCompletionHandler： 中查看是否关闭友盟弹框 结果如下图： 2）查看 友盟推送demo中的代码，是否调用了相同的方法 结果如下图： 比较二者，有没有发现二者的区别；两个方法的调用顺去颠倒也会出现 Bug 的，瞬间解决，哦耶！！！ 5.在友盟后台测试推送通知时，客户端经常收不到通知！！！ 1)请跳转到知乎相关网址去查找相对应的原因; 2)网络很差，推送有延迟，稍等1-3分钟即可收到； 这就是目前在集成友盟推送的开发过程中遇到的一些小插曲， 希望有同样的问题的人可以通过以上解决方法能够顺利解决！！谢谢 如有更多问题请移步到 【友盟+】消息推送常见问题索引]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果内购(IAP)调研报告]]></title>
    <url>%2F2016%2F07%2F25%2F%E8%8B%B9%E6%9E%9C%E5%86%85%E8%B4%AD(IAP)%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[一.适用情况: 什么时候使用苹果内购?为什么时候苹果内购? 在苹果制定的游戏规则中，所有在App内提供的服务需要付费时，都应当使用IAP，比如解锁软件功能、游戏道具；所有在App外提供的服务需要付费时，都应使用其他支付方式，比如比如淘宝、京东等一堆电商，他们的商品都是不存在于App中的。 列举一些相关实例, 1.在IAP里，可以出售： 数字内容：比如杂志、图片、游戏关卡解锁、相机付费滤镜等； 软件功能：如各种扩展features； 一次性服务：比如一次语音通话等。 2.在IAP里，不能出售: 现实世界的商品或服务 3.现在有很多比如网易云课堂，腾讯课堂等等在线教育App，可以在App中购买视频并在APP中观看，也就是说’观看视频’这个功能是本身就存在于APP中的，只是需要你先购买视频，才能使用’观看视频’这个功能，这个时候，这种解锁APP已有功能的操作，就必须要使用iap 当然，肯定有APP不是这样，毕竟谁也不愿意让苹果抽那么多钱，那些APP也许是用了一些什么欺骗手段，比如后台写个开关，审核的时候打开，所有功能都能使用，上线后再关闭开关啊什么的。这样的APP有可能随时会被警告并下架，严重点的封号也不是没可能 o(╯□╰)o 第三点就提到了为什么使用苹果内购? 极大降低了应用审核被拒的风险以及被迫下架的可能性,还可以大力推广应用的付费功能. 二.关于商品类型：iap创建商品时选择的商品类型大概分三类 1.消耗型商品： 就是类似游戏中的钻石，还有现在某些APP中的货币，比如什么鱼丸，鱼翅什么的，会被消耗的，要选择消耗型商品 2.非消耗型商品： 无法被消耗的商品，比如上文提到的视频课程，一次购买，就应该永久可以观看，视频你怎么消耗？打赏多少多少视频？o(╯□╰)o 3.订阅类型商品： 多用于会员，需要注意的一个地方就是苹果似乎没有保存期限，所以这个期限要后台保存的.另外需要注意的一个地方是当APP中有过订阅类型商品，注意是有过，曾经有过删除也算的，这个APP是无法转移账号的. 三.在itunes connect 里面签署相关协议 将上图标注的关于联系人信息,税务,银行信息填写完成就ok. 四.添加内购项目 五.应用内代码实现 &amp;&amp; 沙盒测试 可以参考此博客,博客中介绍的比较详尽. 六.内购的两种模式—内置模式 &amp;&amp; 服务器模式(相对可靠,安全,首选) 使用内置模式。 需要交付的产品已经在程序内部。 这种方式通常用在一些被锁定的功能上。 也可以用来交付在程序束（App Bundle）中的内容。 该方式的一个重要的优点是你可以及时的给客户交付产品，大多数的内置产品应为非消耗性商品。 使用服务器模式，要提供另外的服务器将产品发送给程序。 服务器交付适用于订阅、内容类商品和服务，因为商品可以作为数据发送，而不需改动程序束。 例如，一个游戏提供的新的内容（关卡等）。 Store Kit不会对服务器端的设计和交互做出定义，这方面工作需要你来完成。 而且，Store Kit不提供验证用户身份的机制，你需要来设计。 如果你的程序需要以上功能，例如，纪录特定用户的订阅计划， 你需要自己来设计和实现。 1.内置模式的流程： app从app store 获取产品信息 用户选择需要购买的产品 app发送支付请求到AppStore AppStore处理支付请求,返回transaction信息 app将购买的内容展示给用户 2.服务器模式的流程: app从服务器获取产品标识列表 app从app store 获取产品信息 用户选择需要购买的产品 app 发送支付请求到AppStore AppStore处理支付请求,返回transaction信息 app将 transaction receipt 发送到服务器 服务器收到收据后发送到app stroe验证收据的有效性 app store 返回收据的验证结果 根据app store 返回的结果决定用户是否购买成功 上述两种模式的不同之处主要在于：交易的收据验证，内建模式没有专门去验证交易收据，而服务器模式会使用独立的服务器去验证交易收据。内建模式简单快捷，但容易被破解。服务器模式流程相对复杂，但相对安全 开发之初，苹果官方就很负责的告知:我们的服务器不稳定。真正开发之后，发现苹果方果然是很负责的，不仅是不稳定，而且足够慢。app store server验证一个收据需要3-6s时间 用户能否忍受3-6s的等待时间 如果app store server 宕机，如何确保成功付费的用户能够得到正常服务。 对于第一个问题，我们有理由相信用户完全无法忍受，所以采用异步验证的方式，服务器收到客户端的请求后，就将请求放到MCQ中去处理。 对于第二个问题，由于苹果人员很负责人的告知：我们的服务器不稳定，所以不排除收据验证超时的情况。对于验证超时的收据，保存到数据库中并标记为验证超时，定时任务每隔一定的时间去app store验证，确保能够获取收据的验证结果。此处摘自博客]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置tableView的分割线顶两端]]></title>
    <url>%2F2016%2F01%2F12%2F%E8%AE%BE%E7%BD%AEtableView%E7%9A%84%E5%88%86%E5%89%B2%E7%BA%BF%E9%A1%B6%E4%B8%A4%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[在最近的项目中设计图如下 分割线顶在 两端，于是搜集了相关的实现方法 在控制器空加入如下代码，123456789101112- (void)viewDidLayoutSubviews &#123; [super viewDidLayoutSubviews]; if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) &#123; [self.tableView setSeparatorInset:UIEdgeInsetsMake(0, 0, 0, 0)]; &#125; if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) &#123; [self.tableView setLayoutMargins:UIEdgeInsetsMake(0, 0, 0, 0)]; &#125;&#125; 并且cell的相关设置方法- (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath 中调用下列方法123456789101112- (void)setSeparatorInsetForCell:(UITableViewCell*)cell &#123; [cell setSelectionStyle:UITableViewCellSelectionStyleNone]; if ([cell respondsToSelector:@selector(setSeparatorInset:)]) &#123; [cell setSeparatorInset:UIEdgeInsetsMake(0, 0, 0, 0)]; &#125; if ([cell respondsToSelector:@selector(setLayoutMargins:)]) &#123; [cell setLayoutMargins:UIEdgeInsetsMake(0, 0, 0, 0)]; &#125;&#125; 这是比较小众的方法来实现 特定的需求。]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS的后台机制]]></title>
    <url>%2F2015%2F12%2F10%2FiOS%E7%9A%84%E5%90%8E%E5%8F%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[最近在修改项目中的bug过程中,遇到了 设备锁屏无法定位的情况. 于是搜查了Apple相关的后台机制,原文在此 OS 7中，实际上APP拥有四种后台模式，无论是哪一种后台机制，均需要利用苹果给予的相应后台接口实现。IOS7系统中，开发者可以灵活利用多种后台接口（API）实现更加智能的应用操作。 一、无后台仅推送第 一种后台方式为传统的无后台操作，仅有苹果推送机制，这种方式出现在iOS 3.x以下的大部分系统版本上。这个方式下，应用在按下Home键后即会关闭退出，其数据通过苹果搭建的推送服务器传输，并不需要应用后台运行。这种方式 不太好的原因在于，每次推出后，重新进入均需要重新加载，虽然推送能够统一解决数据和信息的传输，但遇到需要频繁进入应用（如聊天APP）的时候便会显得 体验不好。 二、墓碑式第二种方式为墓碑式的后台机制，这在iOS 4后被大量采用，也就是人们所说的伪多任务。这方式相比较第一种改进的地方在于，按下Home键至主界面后，应用随即进入后台，但其被冻结，并不能进行任何操作。 三、智能调度后台第三种为系统智能调度的后台，iOS 7新增的background fetch， 这个后台接口在苹果WWDC 2013上有提及，其会根据用户行为自动调整达到效率最优的后台模式，能够处理不是很有时效性的信息获取。例如一些社交、新闻类的应用的后台信息更 新，iOS系统便会根据应用启动频率、时间和当前网络和电量的状况来智能分配每个应用的后台获取频率和启动时长。 由于拥有该接口的应用的数据后台 刷新操作是统一调度的，因此系统可以在一个进程里面获得多个应用的数据，类似统一的推送机制，这样就能够最大限度地省电。 不过这个方式也有一个缺点，那便是开发者不能设定数据具体什么时候更新，因此这个后台方式只能应用在一些时效性和敏感度不高的地方。 四、真后台第四种方式便是真后台机制，但iOS的真后台与Android的后台机制是不一样的，为了兼顾系统体验和统一进程管理，iOS在这上面加入了众多的限制。大致拥有以下几个后台接口模式： *1、Background Audio，这是后台的音频，这个很早之前便有，也是iOS设备中用得最多的后台应用，调用这个接口可以实现后台的音乐播放。 2、Location Services，这是后台的定位，系统会拥有统一页面进行管理。 3、VoIP，后台语音服务，类似Skype通话应用需要调用，可进行后台的语音通话。 4、Newsstand，报刊杂志后台自动下载更新，其能够自动实时更新。 5、 Background Task Completion，这个接口早在iOS 4时候便拥有，其可以供任意类型的APP使用，不过在旧系统中，这个接口的后台限制运行时间仅为10分钟，意味着当应用退至后台，其后台运行仅能持续10 分钟便会转至休眠状态。iOS 7中对这个接口作出了改变，原来的为连续10分钟，即不论你这10分钟内用户是否关闭屏幕进入休眠状态，应用仍然会在后台等待10分钟完结后推出，而新的 改进为假如遇到关闭屏幕休眠的情况，这后台运行的10分钟便会跟随一同休眠，剩余的后台时间将会留待用户再一次唤醒设备才计算。这样后台运行的时间仍然为 10分钟，但并不连续，这样做的优点为省电。 如现在有一些词典应用带有后台复制选词功能，实际上其是利用了这个接口，如果用户开启词典后并推出，即使屏幕关闭，但词典仍然在后台运行，电量消耗还是比较大的，在iOS 7上，这个问题可以得到解决。 6、 Remote Notification，这是本次较大的一个改进接口，以往聊天类应用接受推送后点进去需要再收一次信息，这情况在QQ、微信等应用上最为明显。不过拥 有了这个接口后，这情况将不复存在，以后推送将能够直接启动后台任务。值得注意的是remote notification支持silent notification（静默推送），这样dropbox这类同步应用可以在后台以最节能的模式实时静默同步了，类似布卡漫画这种也可以推送正在追的漫 画的新章节并在后台静默下载，待到下载好再给用户发送一个本地推送，用户点开即看无需再联网 7、Background Transfer Service，后台上传下载。iOS最接近传统多任务的后台接口，可供任意类型的app调用，无时间限制。应用场景包括后台上传和下载数据，这使得游戏 后台更新数据包，后台上传视频等等都成为可能，但是正如其名字，它只能用于处理上传下载这种传输类的任务，类似后台剪切板监控这种它就无能为力了。 可以在TARGETS中查找相关选项即可查找到background模式的相关设置,并且这些设置最后会在pilist文件中有体现…示例图]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appdelegate中代理方法]]></title>
    <url>%2F2015%2F11%2F23%2FAppdelegate%E4%B8%AD%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近项目要加上一个手势解锁，然而手机解锁的逻辑十分混乱，需要与应用程序启动、应用前后台切换执行的delegate 方法分析清楚！ 1.起初需求：要在程序第一次启动时，就需要设置解锁手势，于是在代理方法1- (void)applicationDidBecomeActive:(UIApplication *)application中写了相关判断方法； 2.需求改变：要在用户有需求时设置手势解锁；于是在代理方法1- (void)applicationWillEnterForeground:(UIApplication *)application中卸了相关判断方法。 3.在此过程中，仔细琢磨了 Appdelegate 中代理方法在前后台切换中的执行 首次运行：123- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions- (void)applicationDidBecomeActive:(UIApplication *)application 首次关闭（home）：123- (void)applicationWillResignActive:(UIApplication *)application- (void)applicationDidEnterBackground:(UIApplication *)application 再次运行：123- (void)applicationWillEnterForeground:(UIApplication *)application- (void)applicationDidBecomeActive:(UIApplication *)application 再次关闭：123- (void)applicationWillResignActive:(UIApplication *)application- (void)applicationDidEnterBackground:(UIApplication *)application 除此之外，再附上两个使用过的比较好的手势解锁框架—–LLLockView 和 CoreLock 非常感谢两位人员，为我们提供了如此强大的开源框架！]]></content>
      <categories>
        <category>研发随笔</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2015%2F03%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>技术拓展</category>
      </categories>
      <tags>
        <tag>jss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2015%2F02%2F07%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[经过两三天的努力终于搭建了属于自己的博客;今天写下了第一篇博客!记录生活中的喜怒哀乐,开发中的收获与经验,旅游途中的感想... GO! GO! GO! 欢迎光临我的 [个人博客](https://fourvcat.cc)!]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
</search>
